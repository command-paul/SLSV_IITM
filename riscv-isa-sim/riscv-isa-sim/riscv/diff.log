Only in ./: BROWSE
Only in ./: csr_disass.h
diff -bur ./debug_module.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/debug_module.cc
--- ./debug_module.cc	2017-06-10 21:48:33.360190801 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/debug_module.cc	2017-06-12 19:19:40.064121903 +0530
@@ -463,9 +463,11 @@
         return true;
 
       case DMI_ABSTRACTAUTO:
-        abstractauto.autoexecprogbuf = get_field(value, DMI_ABSTRACTAUTO_AUTOEXECPROGBUF);
-        abstractauto.autoexecdata = get_field(value, DMI_ABSTRACTAUTO_AUTOEXECDATA);
-        break;
+        abstractauto.autoexecprogbuf = get_field(value,
+            DMI_ABSTRACTAUTO_AUTOEXECPROGBUF);
+        abstractauto.autoexecdata = get_field(value,
+            DMI_ABSTRACTAUTO_AUTOEXECDATA);
+        return true;
     }
   }
   return false;
Only in ./: #devices.h#
diff -bur ./devices.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/devices.h
--- ./devices.h	2017-06-07 08:07:48.724710509 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/devices.h	2017-06-12 19:19:40.064121903 +0530
@@ -52,10 +52,9 @@
   bool store(reg_t addr, size_t len, const uint8_t* bytes) { return false; }
   char* contents() { return data; }
   size_t size() { return len; }
-  char* data;
   
  private:
-  
+  char* data;
   size_t len;
 };
 
Only in ./: diff.log
diff -bur ./execute.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/execute.cc
--- ./execute.cc	2017-06-10 22:57:35.264276233 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/execute.cc	2017-06-12 19:19:40.064121903 +0530
@@ -1,10 +1,10 @@
 // See LICENSE for license details.
-#include "var_track.h"
+
 #include "processor.h"
 #include "mmu.h"
 #include "sim.h"
 #include <cassert>
-#include "csr_disass.h"
+
 
 static void commit_log_stash_privilege(state_t* state)
 {
@@ -16,45 +16,19 @@
 static void commit_log_print_insn(state_t* state, reg_t pc, insn_t insn)
 {
 #ifdef RISCV_ENABLE_COMMITLOG
-  extern var_track Single_Core_Track;
   int32_t priv = state->last_inst_priv;
   uint64_t mask = (insn.length() == 8 ? uint64_t(0) : (uint64_t(1) << (insn.length() * 8))) - 1;
-  //Change in Register || I'm keeping them seperate because a format has not been defined for verification 
-  bool xf =state->log_reg_write.addr & 1 ;
-  unsigned int reg_addr  = state->log_reg_write.addr>>1;  
-  if ((state->log_reg_write.addr != 0) && ((Single_Core_Track.careX(reg_addr)&&(xf==0)) || (Single_Core_Track.careF(reg_addr)&& (xf==1)))) {
-    fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ") %c%2" PRIu64 " 0x%016" PRIx64 "::::%d,%u\n",
+  if (state->log_reg_write.addr) {
+    fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ") %c%2" PRIu64 " 0x%016" PRIx64 "\n",
             priv,
             pc,
             insn.bits() & mask,
-            state->log_reg_write.addr & 1 ? 'f' : 'x', // original inplememtation reg update print
+            state->log_reg_write.addr & 1 ? 'f' : 'x',
             state->log_reg_write.addr >> 1,
-            state->log_reg_write.data,xf,reg_addr);
-  } 
-  //change in memory
-  else if ((state->store_addr)&&(Single_Core_Track.careM(state->store_addr))) {
-    fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ") STORE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- MEM:: 0x%016" PRIu64 " 0x%016" PRIu64 "\n",
-            priv,
-            pc,
-            insn.bits() & mask,
-            state->store_addr,
-            state->store_val);
-  }
-  // Change in CSR triggered by SetCSR function -- need to expand to support changes affected otherwise
-  else if ((state->csr_addr > 0)&&(Single_Core_Track.careC(state->csr_addr))){
-    fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ") %s %d 0x%016" PRIx64 "\n",
-            priv,
-            pc,
-            insn.bits() & mask,
-            csr_disass(state->csr_addr).c_str(),
-            state->csr_addr,
-            state->csr_val);
-  }
-  else {
-    if (Single_Core_Track.careP(0)) fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ")\n", priv, pc, insn.bits() & mask);
+            state->log_reg_write.data);
+  } else {
+    fprintf(stderr, "%1d 0x%016" PRIx64 " (0x%08" PRIx64 ")\n", priv, pc, insn.bits() & mask);
   }
-  state->csr_addr = -1;
-  state->store_addr = 0;
   state->log_reg_write.addr = 0;
 #endif
 }
diff -bur ./insns/fmax_d.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmax_d.h
--- ./insns/fmax_d.h	2017-05-28 21:40:05.317834450 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmax_d.h	2017-06-12 19:19:40.068121903 +0530
@@ -1,6 +1,8 @@
 require_extension('D');
 require_fp;
-WRITE_FRD(f64_le_quiet(f64(FRS2), f64(FRS1)) || isNaNF64UI(f64(FRS2).v) ? FRS1 : FRS2);
-if ((isNaNF64UI(f64(FRS1).v) && isNaNF64UI(f64(FRS2).v)) || softfloat_exceptionFlags)
+bool greater = f64_lt_quiet(f64(FRS2), f64(FRS1)) ||
+               (f64_eq(f64(FRS2), f64(FRS1)) && (f64(FRS2).v & F64_SIGN));
+WRITE_FRD(greater || isNaNF64UI(f64(FRS2).v) ? FRS1 : FRS2);
+if (isNaNF64UI(f64(FRS1).v) && isNaNF64UI(f64(FRS2).v))
   WRITE_FRD(f64(defaultNaNF64UI));
 set_fp_exceptions;
diff -bur ./insns/fmax_s.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmax_s.h
--- ./insns/fmax_s.h	2017-05-28 21:40:05.317834450 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmax_s.h	2017-06-12 19:19:40.068121903 +0530
@@ -1,6 +1,8 @@
 require_extension('F');
 require_fp;
-WRITE_FRD(f32_le_quiet(f32(FRS2), f32(FRS1)) || isNaNF32UI(f32(FRS2).v) ? FRS1 : FRS2);
-if ((isNaNF32UI(f32(FRS1).v) && isNaNF32UI(f32(FRS2).v)) || softfloat_exceptionFlags)
+bool greater = f32_lt_quiet(f32(FRS2), f32(FRS1)) ||
+               (f32_eq(f32(FRS2), f32(FRS1)) && (f32(FRS2).v & F32_SIGN));
+WRITE_FRD(greater || isNaNF32UI(f32(FRS2).v) ? FRS1 : FRS2);
+if (isNaNF32UI(f32(FRS1).v) && isNaNF32UI(f32(FRS2).v))
   WRITE_FRD(f32(defaultNaNF32UI));
 set_fp_exceptions;
diff -bur ./insns/fmin_d.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmin_d.h
--- ./insns/fmin_d.h	2017-05-28 21:40:05.317834450 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmin_d.h	2017-06-12 19:19:40.068121903 +0530
@@ -1,6 +1,8 @@
 require_extension('D');
 require_fp;
-WRITE_FRD(f64_lt_quiet(f64(FRS1), f64(FRS2)) || isNaNF64UI(f64(FRS2).v) ? FRS1 : FRS2);
-if ((isNaNF64UI(f64(FRS1).v) && isNaNF64UI(f64(FRS2).v)) || softfloat_exceptionFlags)
+bool less = f64_lt_quiet(f64(FRS1), f64(FRS2)) ||
+            (f64_eq(f64(FRS1), f64(FRS2)) && (f64(FRS1).v & F64_SIGN));
+WRITE_FRD(less || isNaNF64UI(f64(FRS2).v) ? FRS1 : FRS2);
+if (isNaNF64UI(f64(FRS1).v) && isNaNF64UI(f64(FRS2).v))
   WRITE_FRD(f64(defaultNaNF64UI));
 set_fp_exceptions;
diff -bur ./insns/fmin_s.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmin_s.h
--- ./insns/fmin_s.h	2017-05-28 21:40:05.317834450 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/insns/fmin_s.h	2017-06-12 19:19:40.068121903 +0530
@@ -1,6 +1,8 @@
 require_extension('F');
 require_fp;
-WRITE_FRD(f32_lt_quiet(f32(FRS1), f32(FRS2)) || isNaNF32UI(f32(FRS2).v) ? FRS1 : FRS2);
-if ((isNaNF32UI(f32(FRS1).v) && isNaNF32UI(f32(FRS2).v)) || softfloat_exceptionFlags)
+bool less = f32_lt_quiet(f32(FRS1), f32(FRS2)) ||
+            (f32_eq(f32(FRS1), f32(FRS2)) && (f32(FRS1).v & F32_SIGN));
+WRITE_FRD(less || isNaNF32UI(f32(FRS2).v) ? FRS1 : FRS2);
+if (isNaNF32UI(f32(FRS1).v) && isNaNF32UI(f32(FRS2).v))
   WRITE_FRD(f32(defaultNaNF32UI));
 set_fp_exceptions;
diff -bur ./interactive.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/interactive.cc
--- ./interactive.cc	2017-06-07 22:12:23.854331591 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/interactive.cc	2017-06-12 19:19:40.068121903 +0530
@@ -57,16 +57,6 @@
   return s;
 }
 
-
-// this union declarition has been moved up in the code .
-union fpr
-{
-  freg_t r;
-  float s;
-  double d;
-};
-
-
 void sim_t::interactive()
 {
   typedef void (sim_t::*interactive_func)(const std::string&, const std::vector<std::string>&);
@@ -88,87 +78,12 @@
   funcs["q"] = funcs["quit"];
   funcs["help"] = &sim_t::interactive_help;
   funcs["h"] = funcs["help"];
-  //added mappings
-  funcs["ckpt"] = &sim_t::tst_checkpoint;
-  funcs["rst"] = &sim_t::tst_restore;
-
-// Modifications
-  std::vector<std::string> zero;
-  zero.push_back("0"); // 
-// Modifications End
+
   while (!done())
   {
-    //Modifications
-    //Print PC
-    fprintf(stderr, "0x%016" PRIx64 "\n", sim_t::get_pc(zero));
-    //Print RF
-    processor_t *p = get_core((size_t)0);
-    state_t* proc_csr = p->get_state();
-    for (int r = 0; r < NXPR; ++r) {
-      fprintf(stderr, "%-4s: 0x%016" PRIx64 "  ", xpr_name[r], p->state.XPR[r]);
-      // fpr f;
-      // f.r = get_freg(zero);
-      // fprintf(stderr, "%g\n",f.s);
-      // f.r = get_freg(zero);    
-      // fprintf(stderr, "%g\n",f.d);
-      if ((r + 1) % 4 == 0)
-        fprintf(stderr, "\n");
-    }
-  //fprintf(stderr, "%-4s: 0x%016" PRIx64 "  ", xpr_namer[r], p->state.XPR[r])
-  fprintf(stderr,"prv       : 0x%016" PRIx64" \n" , p->state.prv);   
-  fprintf(stderr,"mstatus   : 0x%016" PRIx64" \n" , p->state.mstatus);   
-  fprintf(stderr,"mepc      : 0x%016" PRIx64" \n" , p->state.mepc);   
-  fprintf(stderr,"mbadaddr  : 0x%016" PRIx64" \n" , p->state.mbadaddr);   
-  fprintf(stderr,"mscratch  : 0x%016" PRIx64" \n" , p->state.mscratch);   
-  fprintf(stderr,"mtvec     : 0x%016" PRIx64" \n" , p->state.mtvec);   
-  fprintf(stderr,"mcause    : 0x%016" PRIx64" \n" , p->state.mcause);   
-  fprintf(stderr,"minstret  : 0x%016" PRIx64" \n" , p->state.minstret);   
-  fprintf(stderr,"mie       : 0x%016" PRIx64" \n" , p->state.mie);   
-  fprintf(stderr,"mip       : 0x%016" PRIx64" \n" , p->state.mip);   
-  fprintf(stderr,"medeleg   : 0x%016" PRIx64" \n" , p->state.medeleg);   
-  fprintf(stderr,"mideleg   : 0x%016" PRIx64" \n" , p->state.mideleg);   
-  fprintf(stderr,"sepc      : 0x%016" PRIx64" \n" , p->state.sepc);   
-  fprintf(stderr,"sbadaddr  : 0x%016" PRIx64" \n" , p->state.sbadaddr);   
-  fprintf(stderr,"sscratch  : 0x%016" PRIx64" \n" , p->state.sscratch);   
-  fprintf(stderr,"stvec     : 0x%016" PRIx64" \n" , p->state.stvec);   
-  fprintf(stderr,"sptbr     : 0x%016" PRIx64" \n" , p->state.sptbr);   
-  fprintf(stderr,"scause    : 0x%016" PRIx64" \n" , p->state.scause);   
-  fprintf(stderr,"dpc       : 0x%016" PRIx64" \n" , p->state.dpc);   
-  fprintf(stderr,"dscratch  : 0x%016" PRIx64" \n" , p->state.dscratch);   
-  fprintf(stderr,"tselect   : 0x%016" PRIx64" \n" , p->state.tselect);   
-  //this_is_a_scope_check((int)100);
-  //uint3 mcounteren;
-  //uint3 scounteren;
-
-  //    long unsigned int val;
-  //   mmu_t* mmu = debug_mmu;
-  //   mmu = p->get_mmu();
-  // //addr_str = args[1];
-  
-  // //reg_t addr = strtol(addr_str.c_str(),NULL,16), val;
-  // reg_t addr;
-  // for(addr=0;addr<4096;addr++){
-  //   switch(addr % 8)
-  //   {
-  //     case 0:
-  //       val = mmu->load_uint64(addr);
-  //       break;
-  //     case 4:
-  //       val = mmu->load_uint32(addr);
-  //       break;
-  //     case 2:
-  //     case 6:
-  //       val = mmu->load_uint16(addr);
-  //       break;
-  //     default:
-  //       val = mmu->load_uint8(addr);
-  //       break;
-  //   }
-  //  fprintf(stderr, "0x%016" PRIx64 "\n", val);
-  // }
-    //Modifications
     std::cerr << ": " << std::flush;
     std::string s = readline(2);
+
     std::stringstream ss(s);
     std::string cmd, tmp;
     std::vector<std::string> args;
@@ -195,63 +110,6 @@
   ctrlc_pressed = false;
 }
 
-void sim_t::tst_checkpoint(const std::string& cmd, const std::vector<std::string>& args){
-  //processor_t* p = procs[0]; //  this limits our ex to only one cpu
-  //processor_t 
-  //Single_Core_Checkpoint_VCT.push_back(procs[0]);
-
-  // push to state snap vector
-  // Done  std::vector<state_t> state_vect;
-  // Done  std::vector<mmu_t> mmu_vect;
-  processor_t* p = procs[0];
-  mem_ckpt.push_back( (char*)malloc(sizeof(char)*(((unsigned long)2048)<<20)));
-  
-  if(mem_ckpt.back() == NULL){
-    fprintf(stderr,"Malloc Fail\n");   
-    exit(-1);
-  }
-  fprintf(stderr,"WARNING :: Each Checkpoint uses 2GB of memory (Default)\n");
-  //mems.second->data
-  memcpy(mem_ckpt.back(),mems.back().second->data,(sizeof(char)*(((unsigned long)2048)<<20)));
-  state_vect.push_back(p->state);
-  //mmu_vect.push_back(p->mmu);
-  //std::vector<extra_state_csr_t> e_state_vect; There doesnt seem to be anything the docs prob ref to an older version of the processor_t impl ?
-  //std::vector<icache_sim_t> icache_stat_vect; // these stats will be implemented later - not critical
-  //std::vector<dcache_sim_t> dcache_stat_vect; // these stats will be implemented alter - not critical
-
-   // psh to mem snap vector
-  // psh to csr array
-  // psh Cache statistics
-
-  // serialise and write to file 
-}
-void sim_t::tst_restore(const std::string& cmd, const std::vector<std::string>& args){
-  //procs[0] = Single_Core_Checkpoint_VCT.back();
-
-  // read from file and de serialise 
-  if(!mem_ckpt.empty()){
-    processor_t* p = procs[0];
-    p->state  = state_vect.back();
-    //p->mmu    = mmu_vect.back();
-    state_vect.pop_back();
-    memcpy(mems.back().second->data,mem_ckpt.back(),(sizeof(char)*(((unsigned long)2048)<<20)));
-    //mmu_vect.pop_back();
-    free(mem_ckpt.back());
-    mem_ckpt.pop_back();
-    p->mmu->flush_tlb();
-  }
-  else{
-    fprintf(stderr,"No Restore Points in Stack\n");
-  }
-  // Restore state from state snap vector
-  // restore mem from mem snap vector
-  // restor CSR from csr array
-  // flush TLB 
-  // Restore Cache statistics
-  //
-
-}
-
 void sim_t::interactive_help(const std::string& cmd, const std::vector<std::string>& args)
 {
   std::cerr <<
@@ -372,6 +230,12 @@
     fprintf(stderr, "0x%016" PRIx64 "\n", get_reg(args));
 }
 
+union fpr
+{
+  freg_t r;
+  float s;
+  double d;
+};
 
 void sim_t::interactive_freg(const std::string& cmd, const std::vector<std::string>& args)
 {
diff -bur ./jtag_dtm.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/jtag_dtm.cc
--- ./jtag_dtm.cc	2017-05-28 21:40:05.317834450 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/jtag_dtm.cc	2017-06-12 19:19:40.068121903 +0530
@@ -41,7 +41,7 @@
   dm(dm),
   _tck(false), _tms(false), _tdi(false), _tdo(false),
   dtmcontrol((abits << DTM_DTMCS_ABITS_OFFSET) | 1),
-  dmi(DMI_OP_STATUS_FAILED << DTM_DMI_OP_OFFSET),
+  dmi(DMI_OP_STATUS_SUCCESS << DTM_DMI_OP_OFFSET),
   _state(TEST_LOGIC_RESET)
 {
 }
diff -bur ./mmu.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/mmu.cc
--- ./mmu.cc	2017-06-07 22:12:21.058331476 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/mmu.cc	2017-06-12 19:19:40.072121903 +0530
@@ -163,7 +163,7 @@
   if (vm.levels == 0)
     return addr & ((reg_t(2) << (proc->xlen-1))-1); // zero-extend from xlen
 
-  bool supervisor = mode == PRV_S;
+  bool s_mode = mode == PRV_S;
   bool sum = get_field(proc->state.mstatus, MSTATUS_SUM);
   bool mxr = get_field(proc->state.mstatus, MSTATUS_MXR);
 
@@ -189,7 +189,7 @@
 
     if (PTE_TABLE(pte)) { // next level of page table
       base = ppn << PGSHIFT;
-    } else if ((pte & PTE_U) ? supervisor && !sum : !supervisor) {
+    } else if ((pte & PTE_U) ? s_mode && (type == FETCH || !sum) : !s_mode) {
       break;
     } else if (!(pte & PTE_V) || (!(pte & PTE_R) && (pte & PTE_W))) {
       break;
diff -bur ./mmu.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/mmu.h
--- ./mmu.h	2017-06-07 22:24:01.214360278 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/mmu.h	2017-06-12 19:19:40.072121903 +0530
@@ -113,32 +113,6 @@
   load_func(int64)
 
   // template for functions that store an aligned value to memory
-
-
-  #ifdef RISCV_ENABLE_COMMITLOG
-  #define store_func(type) \
-    void store_##type(reg_t addr, type##_t val) { \
-      if (unlikely(addr & (sizeof(type##_t)-1))) \
-        return misaligned_store(addr, val, sizeof(type##_t)); \
-      reg_t vpn = addr >> PGSHIFT; \
-      if (likely(tlb_store_tag[vpn % TLB_ENTRIES] == vpn)) \
-        *(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = val; \
-      else if (unlikely(tlb_store_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) { \
-        if (!matched_trigger) { \
-          matched_trigger = trigger_exception(OPERATION_STORE, addr, val); \
-          if (matched_trigger) \
-            throw *matched_trigger; \
-        } \
-        *(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = val; \
-      } \
-      else \
-        store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&val); \
-      if(proc!=NULL){ \
-      proc->state.store_addr = addr; \
-      proc->state.store_val  =(uint64_t) val ; \
-      } \
-    }
-    #else  
     #define store_func(type) \
     void store_##type(reg_t addr, type##_t val) { \
       if (unlikely(addr & (sizeof(type##_t)-1))) \
@@ -157,11 +131,6 @@
       else \
         store_slow_path(addr, sizeof(type##_t), (const uint8_t*)&val); \
     } 
-    #endif
-
-
-
-
   
   // template for functions that perform an atomic memory operation
   #define amo_func(type) \
@@ -192,7 +161,6 @@
   amo_func(uint32)
   amo_func(uint64)
 
-
   static const reg_t ICACHE_ENTRIES = 1024;
 
   inline size_t icache_index(reg_t addr)
@@ -251,8 +219,6 @@
 
   void register_memtracer(memtracer_t*);
   
-
-  
 private:
   sim_t* sim;
   processor_t* proc;
diff -bur ./processor.cc /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/processor.cc
--- ./processor.cc	2017-06-10 22:06:11.776212632 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/processor.cc	2017-06-12 19:19:40.072121903 +0530
@@ -283,9 +283,8 @@
       fprintf(stderr, "core %3d: Executed %" PRIx64 " times\n", id, executions);
     }
 
-    // FIXME //
-    //fprintf(stderr, "core %3d: 0x%016" PRIx64 " (0x%08" PRIx64 ") %s\n",
-    //        id, state.pc, bits, disassembler->disassemble(insn).c_str());
+    fprintf(stderr, "core %3d: 0x%016" PRIx64 " (0x%08" PRIx64 ") %s\n",
+            id, state.pc, bits, disassembler->disassemble(insn).c_str());
     last_pc = state.pc;
     last_bits = bits;
     executions = 1;
@@ -302,10 +301,6 @@
 
 void processor_t::set_csr(int which, reg_t val)
 {
-  #ifdef RISCV_ENABLE_COMMITLOG
-  state.csr_addr = which;
-  state.csr_val = val;
-  #endif
   val = zext_xlen(val);
   reg_t delegable_ints = MIP_SSIP | MIP_STIP | MIP_SEIP | (1 << IRQ_COP);
   reg_t all_ints = delegable_ints | MIP_MSIP | MIP_MTIP;
diff -bur ./processor.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/processor.h
--- ./processor.h	2017-06-07 23:13:22.294482090 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/processor.h	2017-06-12 19:19:40.072121903 +0530
@@ -121,8 +121,6 @@
   mcontrol_t mcontrol[num_triggers];
   reg_t tdata2[num_triggers];
 
-
-
   uint32_t fflags;
   uint32_t frm;
   bool serialized; // whether timer CSRs are in a well-defined state
@@ -137,15 +135,9 @@
 
   reg_t load_reservation;
 
-
-
 #ifdef RISCV_ENABLE_COMMITLOG
   commit_log_reg_t log_reg_write;
   reg_t last_inst_priv;
-  uint64_t store_val;
-  reg_t store_addr;
-  int csr_addr;
-  reg_t csr_val;
 #endif
 };
 
@@ -292,8 +284,6 @@
 
   void trigger_updated();
 
-
-
 private:
   sim_t* sim;
   mmu_t* mmu; // main memory is always accessed via the mmu
diff -bur ./riscv.mk.in /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/riscv.mk.in
--- ./riscv.mk.in	2017-06-10 22:06:19.216212785 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/riscv.mk.in	2017-06-12 19:19:40.072121903 +0530
@@ -7,10 +7,8 @@
 riscv_install_prog_srcs = \
 
 riscv_hdrs = \
-	var_track.h \
 	common.h \
 	decode.h \
-	csr_disass.h \
 	devices.h \
 	disasm.h \
 	mmu.h \
@@ -29,9 +27,6 @@
 	remote_bitbang.h \
 	jtag_dtm.h \
 	
-	
-
-
 riscv_precompiled_hdrs = \
 	insn_template.h \
 
@@ -54,7 +49,6 @@
 	debug_module.cc \
 	remote_bitbang.cc \
 	jtag_dtm.cc \
-	var_track.cc \
 	$(riscv_gen_srcs) \
 
 riscv_test_srcs =
diff -bur ./sim.h /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/sim.h
--- ./sim.h	2017-06-10 21:48:37.532190887 +0530
+++ /home/local_install/RISCV_Tools/spike-git/riscv-isa-sim/riscv/sim.h	2017-06-12 19:19:40.072121903 +0530
@@ -2,7 +2,7 @@
 
 #ifndef _RISCV_SIM_H
 #define _RISCV_SIM_H
-#include "var_track.h"
+
 #include "processor.h"
 #include "devices.h"
 #include "debug_module.h"
@@ -14,6 +14,7 @@
 
 class mmu_t;
 class remote_bitbang_t;
+
 // this class encapsulates the processors and memory in a RISC-V machine.
 class sim_t : public htif_t
 {
@@ -38,18 +39,10 @@
 
   debug_module_t debug_module;
   
-  // added state checkpoint vector
-  //std::vector<processor_t> Single_Core_Checkpoint_VCT;
-  std::vector<state_t> state_vect;
-  //std::vector<mmu_t> mmu_vect;
-  std::vector<char*> mem_ckpt;
-
-
 private:
-
   std::vector<std::pair<reg_t, mem_t*>> mems;
   mmu_t* debug_mmu;  // debug port into main memory
-  std::vector<processor_t*> procs; // This is the main processor vector this is where i take the snapshot from and restore to
+  std::vector<processor_t*> procs;
   reg_t start_pc;
   std::string dts;
   std::unique_ptr<rom_device_t> boot_rom;
@@ -77,11 +70,6 @@
   // presents a prompt for introspection into the simulation
   void interactive();
 
-  //PG Added funnctions
-  void tst_checkpoint(const std::string& cmd, const std::vector<std::string>& args);
-  void tst_restore(const std::string& cmd, const std::vector<std::string>& args);
-
-
   // functions that help implement interactive()
   void interactive_help(const std::string& cmd, const std::vector<std::string>& args);
   void interactive_quit(const std::string& cmd, const std::vector<std::string>& args);
Only in ./: .tempmemtrac_h.lop
Only in ./: var_track.cc
Only in ./: var_track.h
